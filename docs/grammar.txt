Gramática da Linguagem:


<Prog> := <Decl> <CmdBlock>
<Decl> := <Consts> <Types> <SubProg> <Vars> 
<Consts> := const <ConstAux> | λ
<ConstAux> := <Id > ':=' <Exp> ';' <ConstAux> | λ



// Seguir a ordem da op_table

LogicTerms :=   LogicTerms '||' LogicFactor
                | LogicFactor | LAMBDA

LogicFactor := LogicFactor '&&' LogicNot | LogicNot |LAMBDA

LogicNot  := '!'Comps | Comps | LAMBDA

Comps :=    Exp    '!='  Exp | Exp   '=='  Exp 
            | Exp   '>'   Exp | Exp   '<'   Exp 
            | Exp   '>='  Exp | Exp   '<='  Exp 
            | Exp | LAMBDA

Exp :=    Exp   '+'   Terms
        | Exp   '-'   Terms
        | Terms| LAMBDA

Terms :=  Terms   '*' Parenthesis
          | Terms '/' Parenthesis
          | Terms '%' Parenthesis
          | Parenthesis | LAMBDA

Parenthesis := UnaryExp | '(' LogicTerms ')'| LAMBDA

UnaryExp := '+'SimpleExp | '-'SimpleExp | SimpleExp | LAMBDA


SimpleExp := NumExp | AcessMemAddr | FuncCall | LAMBDA

NumExp := V_INT | V_REAL | V_BOOL | V_CHAR 

AcessMemAddr := Id | AcessMemAddr.Id | AcessMemAddr [Exp]|LAMBDA

<Types> := 'type' <TypeAux> | λ

<TypeAux> := <Id> ':=' <TypeDec>

<TypeDec> := 
  'bool' | 'int' | 'real' | 'char' | <Id>
  'array' '[' <Interval> ']' 'of' <TypeDec> | 'record' <Fields> 'end'


<Interval> := <Exp> '..' <Exp> | <Exp> '..' <Exp> ',' <Interval>


<Fields> := <FieldAux> <Fields> | λ

<FieldAux> := <Id> ':' <TypeDec>

<SubProgAux> := (ProcedureDecl | FunctionDecl) | λ
<SubProg> := <SubProgAux> | <SubProgAux><SubProg>

<ProcedureDecl> := 'procedure' <Id> '(' <Parameters> ')' <CmdBlock> ';'

<FunctionDecl> := 'function' <Id> '(' <Parameters> ')' ':' <TypeDec> <CmdBlock> ';'

<Parameters> := <ParameterAux> <Parameters> | λ

<ParameterAux> := <Id> ':' <TypeDec>

<Vars> := 'var' <VarAux> | λ

<VarAux> := (<Id> ':' <TypeDecl> ';' ) ∗

<CmdBlock> := 'begin' <Vars> <Cmds> 'end'

<Cmds> := <CmdAux> | <CmdAux> ';' <Cmd> | λ

<CmdAux> := <AcessMemAddr> ':=' <Exp>
  <Id> '(' <Args> ')'
  <CmdBlock> |
  'if' <Exp> 'then' <CmdBlock>
  'if' <Exp> 'then' <CmdBlock> 'else' <CmdBlock>
  'for' <Id> ':=' <Exp > 'to' <Exp> 'step' <Exp> <CmdBlock>
  'loop' <Vars> <Cmds> 'end'
  'exit' 'when'  <Exp >
  'continue'
  'return'
  'return' <Exp>
